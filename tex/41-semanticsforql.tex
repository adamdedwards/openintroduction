\chapter{Semantics for Quantified Logic}
\label{chap:semantics_for_ql}
\markright{Chap \ref{chap:semantics_for_ql}: Semantics for QL}
\setlength{\parindent}{1em}


% *****************************
% *		Creating Models in QL      *
% ****************************

\section{Creating models in Quantified Logic}

In Chapter 3 we developed the truth table system, a semantic method for evaluating sentences and arguments in SL. The method was called semantic, because it involved establishing meanings for all the non-logical parts of a sentence, in this case, the sentence letters. These were called non-logical because their meaning was not fixed by the rules of SL. The logical part of the language was the system of connectives and parentheses. As it turned out, the logical parts of our language were truth functional: the meaning of the larger sentences built up with the connectives and parentheses was simply a function of the truth of the smaller parts. Because the system of sentential connectives and parentheses is truth functional, our semantic system only needed to look at one aspect of the meaning of the sentence letters, their truth value. Thus an interpretation of a sentence in SL simply turned out to be a truth assignment on the sentence letters. That's why you spent Chapter 3 merrily writing Ts and Fs under sentence letters. Each little row of Ts and Fs represented one way of assigning meaning to a sentence or argument, and all the little rows in the truth table represented all the possible ways of assigning meaning to the sentence or argument (at least as far as truth was concerned.) 

In this chapter we are going to develop similar methods for QL. Because QL is a more complicated system than SL developing semantics for QL will be much more complicated, and there will be greater limitations for what we can do with these methods.

\subsection{Basic Models}

The first thing we need to do is to find an equivalent in QL of a little row of Ts and Fs beneath a sentence in SL. We called this little row of Ts and Fs an interpretation, because it gave one aspect of the meaning of the parts of the sentence, namely their truth values. To come up with an interpretation of a sentence in QL, we will need to look at more than the truth or falsity of sentences, though. We have, after all, broken open the atomic sentence to look at its subatomic parts, and now we will need to assign meaning to these parts. The way to start is to look at the symbolization keys we created when we were translating sentences in and out of QL. The symbolization key contained a universe of discourse (UD), a meaning for each predicate, and an object picked out by each term. For example:
\begin{ekey}
\item[UD:] comic book characters
\item[Fx:] $x$ fights crime.
\item[b:] Batman
\item[w:] Bruce Wayne
\end{ekey}

Given this symbolization key, we can translate sentences like this

\begin{earg}
\item[] $Fb$: Batman fights crime.
\item[] $Fw$: Bruce Wayne fights crime.
\item[] $Fb \eif Fw$: If Batman fights crime, then Bruce Wayne fights crime.  
\end{earg}
This symbolization key, along with some basic knowledge of superhero stories, gives us enough information to figure out that the sentence $Fb$ is true. (Notice that the sentence $Fb$ is not true \emph{just because} of the interpretation. The way we interpret the sentence, plus the way the world is, makes the sentence true.) 

This is the information we need to develop an interpretation of sentences in QL. We are not just assigning truth values anymore. We need to get deeper into meaning here, and look at the \emph{reference} of the parts of the sentence. \define{Reference} is an aspect of meaning that deals with the way bits of language pick out or identify objects in the real world. For our purposes the real world is the universe of discourse, the set of objects we are talking about. To explain how a singular term like $b$ refers, we need only point out the member of the UD it refers to, in this case, Batman. In more technical terms, Batman is the \emph{referent} of B. For our purposes it is enough to define a referent like this: the \define{referent} of a term in QL is the unique object picked out by that term. 

(Notice that here to explain what $b$ refers to, I have been forced to simply use another singular term in another language, the name ``Batman.'' To really pick out the object referred to, I would need to draw your attention to something in the actual world, for instance by holding up a comic book and pointing at the character on the cover.)

We want to use similar methods to talk about the meaning of predicates. To do this we will talk about the \emph{extension} of a predicate. The \define{extension} of a predicate is the set of objects in the UD that the predicate applies to. So if $b$ is in the extension of the predicate $F$ then the sentence $Fb$ is true. 

(Identifying the extension of a predicate like $F$ again forces us to rely on another language, English. We can say that the extension of $F$ includes Batman, Superman, Green Lantern, etc. The situation is worse because $F$ has an indefinitely large extension, so we have relied on the English predicate ``fights crime'' to describe it.) 

All this means that we are able to talk about the meaning of sentences in QL entirely in terms of sets. We use curly brackets \{ and \} to denote sets. The members of the set can be listed in any order, separated by commas. The fact that sets can be in any order is important, because it means that \{foo, bar\} and \{bar, foo\} are the same set. It is possible to have a set with no members in it. This is called the \define{empty set}. The empty set is sometimes written as \{\}, but usually it is written as the single symbol $\emptyset$.

We are now able to give the equivalent of a line in a truth table for QL. An interpretation in QL will be called a \emph{model}. A \define{model} of sentences or arguments in QL consists of a set that is the universe of discourse, individual members of that set that are the referents of the singular terms in the sentences or arguments, and subsets of the universe of discourse which are the extensions of the predicates used in the sentences or arguments. 

To see how this works imagine I have a bunch of sentences in QL, which include the predicate $H$ and the singular term $f$. Now consider this symbolization key:
\begin{ekey}
\item[UD:]People who played as part of the Three Stooges
\item[Hx:]$x$ had head hair.
\item[f:] Mister Fine
\end{ekey}

What is the model that corresponds to this interpretation? There were six people who played as part of the Three Stooges over the years, so the UD will have six members: Larry Fine, Moe Howard, Curly Howard, Shemp Howard, Joe Besser, and Curly Joe DeRita. Curly, Joe, and Curly Joe were the only completely bald stooges. The result is this model:
\begin{partialmodel}
	UD & \{Larry, Curly, Moe, Shemp, Joe, Curly Joe\}\\
	\extension{H} & \{Larry, Moe, Shemp\}\\
	\referent{f} & Larry
\end{partialmodel}

You do not need to know anything about the Three Stooges in order to evaluate whether sentences are true or false in this \emph{model}. $Hf$ is true, since the referent of $f$ (Larry) is in the extension of $H$. Both $\exists x Hx$ and $\exists x \enot Hx$ are true, since there is at least one member of the UD that is in the extension of $H$ and at least one member that is not in the extension of $H$. In this way, the model captures all of the formal significance of the interpretation.

\subsection{Models for multiplace predicates}

Now consider this interpretation:
\begin{ekey}
\item{UD:} whole numbers less than 10
\item{Ex:} $x$ is even.
\item{Nx:} $x$ is negative.
\item{Lxy:} $x$ is less than $y$.
\item{Txyz:} $x$ times $y$ equals $z$.
\end{ekey}
What is the model that goes with this interpretation?
The UD is the set $\{1,2,3,4,5,6,7,8,9\}$.

The extension of a one-place predicate like $E$ or $N$ is just the subset of the UD of which the predicate is true. The extension of $E$ is the subset $\{2,4,6,8\}$. There are many even numbers besides these four, but these are the only members of the UD that are even. There are no negative numbers in the UD, so $N$ has an empty extension; i.e. $\extension{N}=\emptyset$.

The extension of a two-place predicate like $L$ is somewhat vexing. It seems as if the extension of $L$ ought to contain 1, since 1 is less than all the other numbers; it ought to contain 2, since 2 is less than all of the other numbers besides 1; and so on. Every member of the UD besides 9 is less than some member of the UD. What would happen if we just wrote $\extension{L}=\{1,2,3,4,5,6,7,8\}$?

The problem is that sets can be written in any order, so this would be the same as writing $\extension{L}=\{8,7,6,5,4,3,2,1\}$. This does not tell us which of the members of the set are less than which other members.

We need some way of showing that 1 is less than 8 but that 8 is not less than 1. The solution is to have the extension of $L$ consist of pairs of numbers. An \define{ordered pair} is like a set with two members, except that the order \emph{does} matter. We write ordered pairs with angle brackets $<$ and $>$. The ordered pair \mbox{$<$foo, bar$>$} is different than the ordered pair \mbox{$<$bar, foo$>$}. The extension of $L$ is a collection of ordered pairs, all of the pairs of numbers in the UD such that the first number is less than the second. Writing this out completely:
\begin{quote}
$\extension{L}=$ \{$<$1,2$>$, $<$1,3$>$, $<$1,4$>$, $<$1,5$>$, $<$1,6$>$, $<$1,7$>$, $<$1,8$>$, $<$1,9$>$,
$<$2,3$>$, $<$2,4$>$, $<$2,5$>$, $<$2,6$>$, $<$2,7$>$, $<$2,8$>$, $<$2,9$>$,
$<$3,4$>$, $<$3,5$>$, $<$3,6$>$, $<$3,7$>$, $<$3,8$>$, $<$3,9$>$,
$<$4,5$>$, $<$4,6$>$, $<$4,7$>$, $<$4,8$>$, $<$4,9$>$,
$<$5,6$>$, $<$5,7$>$, $<$5,8$>$, $<$5,9$>$,
$<$6,7$>$, $<$6,8$>$, $<$6,9$>$,
$<$7,8$>$, $<$7,9$>$,
$<$8,9$>$%
\}
\end{quote}

Three-place predicates will work similarly; the extension of a three-place predicate is a set of ordered triples where the predicate is true of those three things \emph{in that order}. So the extension of $T$ in this model will contain ordered triples like $<$2,4,8$>$, because $2\times 4 = 8$.

Generally, the extension of an n-place predicate is a set of all ordered n-tuples ${<}a_1, a_2,\ldots, a_n{>}$ such that $a_1$--$a_n$ are members of the UD and the predicate is true of $a_1$--$a_n$ in that order.


\subsection{Models for identity}
Identity is a special predicate of QL. We write it a bit differently than other two-place predicates: $x=y$ instead of $Ixy$. We also do not need to include it in a symbolization key. The sentence $x=y$ always means ``$x$ is identical to $y$,''  and it cannot be interpreted to mean anything else. In the same way, when you construct a model, you do not get to pick and choose which ordered pairs go into the extension of the identity predicate. It always contains just the ordered pair of each object in the UD with itself.

The sentence $\forall x Ixx$, which contains an ordinary two-place predicate, is contingent. Whether it is true for an interpretation depends on how you interpret $I$, and whether it is true in a model depends on the extension of $I$.

The sentence $\forall x\ x=x$ is a tautology. The extension of identity will always make it true.

Notice that although identity always has the same interpretation, it does not always have the same extension. The extension of identity depends on the UD. If the UD in a model is the set \{Doug\}, then $\extension{=}$ in that model is \{$<$Doug, Doug$>$\}. If the UD is the set \{Doug, Omar\}, then $\extension{=}$ in that model is \{$<$Doug, Doug$>$, $<$Omar, Omar$>$\}. And so on.

If the referent of two constants is the same, then anything which is true of one is true of the other. For example, if $\referent{a}=\referent{b}$, then $Aa\eiff Ab$, $Ba\eiff Bb$, $Ca\eiff Cb$, $Rca\eiff Rcb$, $\forall x Rxa\eiff \forall x Rxb$, and so on for any two sentences containing $a$ and $b$. In metaphysics, this is called principle of the indiscernibility of identicals

In our system, the reverse of this principle is not true.\label{model.nonidentity} It is possible that anything which is true of $a$ is also true of $b$, yet for $a$ and $b$ still to have different referents. This may seem puzzling, but it is easy to construct a model that shows this. Consider this model:
\begin{partialmodel}
UD & \{Rosencrantz, Guildenstern\}\\
\referent{a} & Rosencrantz\\
\referent{b} & Guildenstern\\
for all predicates \script{P}, \extension{\script{P}} & $\emptyset$\\
\extension{=} & \{$<$Rosencrantz, Rosencrantz$>$,\\
\multicolumn{2}{r}{$<$Guildenstern, Guildenstern$>$\}}
\end{partialmodel}
This specifies an extension for every predicate of QL: All the infinitely-many predicates are empty. This means that both $Aa$ and $Ab$ are false, and they are equivalent; both $Ba$ and $Bb$ are false; and so on for any two sentences that contain $a$ and $b$. Yet $a$ and $b$ refer to different things. We have written out the extension of identity to make this clear: The ordered pair $<\referent{a},\referent{b}>$ is not in it. In this model, $a=b$ is false and $a\neq b$ is true.

\practiceproblems


\problempart
\label{pr.TorF1}
Determine whether each sentence is true or false in the model given.
\begin{partialmodel}
UD & \{Corwin, Benedict\}\\
\extension{A} & \{Corwin, Benedict\}\\
\extension{B} & \{Benedict\}\\
\extension{N} & $\emptyset$\\
\referent{c} & Corwin
\end{partialmodel}
\begin{earg}
\item $Bc$
\item $Ac \eiff \enot Nc$
\item $Nc \eif (Ac \eor Bc)$
\item $\forall x Ax$
\item $\forall x \enot Bx$
\item $\exists x(Ax \eand Bx)$
\item $\exists x(Ax \eif Nx)$
\item $\forall x(Nx \eor \enot Nx)$
\item $\exists x Bx \eif \forall x Ax$
\end{earg}



\problempart
\label{pr.TorF2}
Determine whether each sentence is true or false in the model given.
\begin{partialmodel}
UD & \{Waylan, Willy, Johnny\}\\
\extension{H} & \{Waylan, Willy, Johnny\}\\
\extension{W} & \{Waylan, Willy\}\\
\extension{R} & \{$<$Waylan, Willy$>$,$<$Willy, Johnny$>$,$<$Johnny, Waylan$>$\}\\
\referent{m} & Johnny
\end{partialmodel}
\begin{earg}
\item $\exists x(Rxm \eand Rmx)$
\item $\forall x(Rxm \eor Rmx)$
\item $\forall x(Hx \eiff Wx)$
\item $\forall x(Rxm \eif Wx)$
\item $\forall x\bigl[Wx \eif(Hx \eand Wx)\bigr]$
\item $\exists x Rxx$
\item $\exists x\exists y Rxy$
\item $\forall x \forall y Rxy$
\item $\forall x \forall y (Rxy \eor Ryx)$
\item $\forall x \forall y \forall z\bigl[(Rxy \eand Ryz) \eif Rxz\bigr]$
\end{earg}

\problempart
\label{pr.TorF3}
Determine whether each sentence is true or false in the model given.
\begin{partialmodel}
	UD			& \{Lemmy, Courtney, Eddy\}\\
	\extension{G}	& \{Lemmy, Courtney, Eddy\}\\
	\extension{H}	& \{Courtney\}\\
	\extension{M}	& \{Lemmy, Eddy\}\\
	\referent{c}	& Courtney\\
	\referent{e}	& Eddy
\end{partialmodel}
\begin{earg}
\item $Hc$
\item $He$
\item $Mc \eor Me$
\item $Gc \eor \enot Gc$
\item $Mc \eif Gc$
\item $\exists x Hx$
\item $\forall x Hx$
\item $\exists x \enot Mx$
\item $\exists x(Hx \eand Gx)$
\item $\exists x(Mx \eand Gx)$
\item $\forall x(Hx \eor Mx)$
\item $\exists x Hx \eand \exists x Mx$
\item $\forall x(Hx \eiff \enot Mx)$
\item $\exists x Gx \eand \exists x \enot Gx$
\item $\forall x\exists y(Gx \eand Hy)$
\end{earg}


\problempart
\label{pr.InterpretationToModel}
Write out the model that corresponds to the interpretation given.
\begin{ekey}
\item{UD:} natural numbers from 10 to 13
\item{Ox:} $x$ is odd. 
\item{Sx:} $x$ is less than 7.
\item{Tx:} $x$ is a two-digit number.
\item{Ux:} $x$ is thought to be unlucky.
\item{Nxy:} $x$ is the next number after $y$.
\end{ekey}


% *****************************
% *		Working with Models.       *
% ****************************



\section{Working with Models}
\label{sec.UsingModels}

Working with models is in some ways like working with truth tables and in some ways not. With truth tables, we could conclusively show that a sentence was a tautology or a contradiction, because the truth table would always have a finite number of lines. We cannot, however, use models to show that a sentence is a tautology or a contradiction, because there are infinitely many ways to model a sentence, and and no single way to talk about all of them, the way we talked about all the lines in a truth table. One thing we can do is show conclusively that a sentence is neither a tautology nor a contradiction, and is instead contingent. A contingent sentence will have at least one model where it is false and one model where it is true.

As we shall see, this pattern plays itself out with the other logical properties we have covered. Because there are infinitely many ways to model a sentence, we cannot construct models to prove two sentences equivalent, but we can use them to show that two sentences are not equivalent. We cannot use models to show that a set of sentences is inconsistent, but we can use models to show that a set of sentences is consistent. Finally, we cannot construct a finite number of models to show that an argument is valid, but we can use one to show that an argument is invalid. 

We will use the double turnstile symbol for QL much as we did for SL. ``$\script{A}\sdtstile{}{} \script{B}$''' means that an argument from \script{A} to \script{B} is semantically valid.  $\sdtstile{}{} \script{A}$ means that \script{A} is a semantic tautology. $\script{A} \ndststile{}{} \hspace{.5em} \sdtstile{}{} \script{B}$ means \script{A} and \script{B} are semantically equivalent. 

In \fullref{semantic_definitions_in_SL} we stipulated semantic definitions for various logical concepts in SL that matched our truth table method for determining these concepts. So a sentence was said to be a tautology in SL if the column under its main connective contained only Ts. This was an alternative to saying the the truth table method was an imprecise way of getting at the ordinary language versions of these concepts. We will do something similar for the semantic definitions of logical notions in QL. 

\begin{enumerate}
\item A \define{semantic tautology in QL} is a sentence \script{A} that is true in every model; i.e.,  $\sdtstile{}{} \script{A}$.

\item A \define{semantic contradiction in QL} is a sentence \script{A} that is false in every model; i.e., $\sdtstile{}{} \enot\script{A}$.

\item A sentence is \define{semantically contingent in QL} if and only if it is neither a tautology nor a contradiction.

\item Two sentences \script{A} and \script{B} are \define{semantically equivalent in QL} if and only if they have the same truth value in every model.

\item The set $\{\script{A}_1,\script{A}_2,\script{A}_3,\cdots\}$ is \define{semantically consistent in QL} if and only if there is at least one model in which all of the sentences are true. The set is \define{semantically inconsistent in QL} if and if only there is no such model.

\item An argument `` $\script{P}_1, \script{P}_2, \cdots$, \therefore\ \script{C} '' is \define{semantically valid in QL} if and only if there is no model in which all of the premises are true and the conclusion is false; i.e., $\{\script{P}_1,\script{P}_2,\cdots\}\sdtstile{}{}\script{C}$. It is \define{semantically invalid in QL} otherwise.
\end{enumerate}


\subsection{Models to show contingency}

Suppose we want to show that $\forall xAxx \eif Bd$ is \emph{not} a tautology. This requires showing that the sentence is not true in every model; i.e., that it is false in some model. If we can provide just one model in which the sentence false, then we will have shown that the sentence is not a tautology.

What would such a model look like? In order for $\forall xAxx \eif Bd$ to be false, the antecedent ($\forall x Axx$) must be true, and the consequent ($Bd$) must be false.

To construct such a model, we start with a UD. It will be easier to specify extensions for predicates if we have a small UD, so start with a UD that has just one member. Formally, this single member might be anything, so let's just call it $\alpha.$ 

We want $\forall x Axx$ to be true, so we want all members of the UD to be paired with themselves in the extension of $A$; this means that the extension of $A$ must be \{$<\alpha,\alpha>$\}.

We want $Bd$ to be false, so the referent of $d$ must not be in the extension of $B$. We give $B$ an empty extension.

Since $\alpha$ is the only member of the UD, it must be the referent of $d$. The model we have constructed looks like this:
\begin{partialmodel}
	UD			& \{$\alpha$\}\\
	\extension{A} 	& \{$<\alpha, \alpha>$\}\\
	\extension{B}	& $\emptyset$\\
	\referent{d}	& $\alpha$
\end{partialmodel}

Strictly speaking, a model specifies an extension for \emph{every} predicate of QL and a referent for \emph{every} constant. As such, it is generally impossible to write down a complete model. That would require writing down infinitely many extensions and infinitely many referents. However, we do not need to consider every predicate in order to show that there are models in which $\forall xAxx \eif Bd$ is false. Predicates like $H$ and constants like $f_{13}$ make no difference to the truth or falsity of this sentence. It is enough to specify extensions for $A$ and $B$ and a referent for $d$, as we have done. This provides a \emph{partial model} in which the sentence is false.

Perhaps you are wondering: What is $\alpha$? What does the predicate $A$ mean in English? The partial model could correspond to an interpretation like this one:
\begin{ekey}
\item[UD:] Paris
\item[$Axy$:] $x$ is in the same country as $y$.
\item[$Bx$:] $x$ was founded in the 20th century.
\item[$d$:] the City of Lights
\end{ekey}

However, we don't have to say that this model corresponds to any particular interpretation of the sentence in English in order to know that the sentence $\forall xAxx \eif Bd$  is not a tautology. We could have made our one-object universe of discourse contain only Mahatma Gandhi, or a pebble on a beach in Africa, or the number 2. As long as the predicate and terms were given the right reference, the sentence would come out false. Thus in the future we can evalaute sentences and arguments using UDs with arbitrarily named elements, like $\alpha$, $\beta$, $\gamma$, etc. 

We use the same method to show that $\forall xAxx \eif Bd$ is not a contradiction. We need only specify a model in which $\forall xAxx \eif Bd$ is true; i.e., a model in which either $\forall x Axx$ is false or $Bd$ is true. Here is one such partial model:
\begin{partialmodel}
	UD			& \{$\alpha$\}\\
	\extension{A} 	& \{$<\alpha,\alpha>$\}\\
	\extension{B}	& \{$\alpha$\}\\
	\referent{d}	& $\alpha$
\end{partialmodel}

We have now shown that $\forall xAxx \eif Bd$ is neither a tautology nor a contradiction. By the definition of ``contingent in QL,'' this means that $\forall xAxx \eif Bd$ is contingent. In general, showing that a sentence is contingent will require two models: one in which the sentence is true and another in which the sentence is false.

Notice, however, that we cannot show that a sentence actually is a tautology or a contradiction using one or two models this way. For a sentence to be a tautology, it must be true in every possible model. Similarly, if a sentence is a contradiction, it is false in all possible models. But there are infinitely many possible models for any sentence, and we don't have any tools in this text that will let us reason about all of them at once. 

\subsection{Models to show non-equivalence}

Suppose we want to show that $\forall x Sx$ and $\exists x Sx$ are \emph{not} logically equivalent. We need to construct a model in which the two sentences have different truth values; we want one of them to be true and the other to be false. We start by specifying a UD. Again, we make the UD small so that we can specify extensions easily. We will need at least two members. Let the UD be \{$\alpha$, $\beta$\}. (If we chose a UD with only one member, the two sentences would end up with the same truth value. In order to see why, try constructing some partial models with one-member UDs.)

We can make $\exists x Sx$ true by including something in the extension of $S$, and we can make $\forall x Sx$ false by leaving something out of the extension of $S$. It does not matter which one we include and which one we leave out. Making $\alpha$ the only $S$, we get a partial model that looks like this:
\begin{partialmodel}
	UD			& \{$\alpha$, $\beta$\}\\
	\extension{S}	& \{$\alpha$\}
\end{partialmodel}
This partial model shows that the two sentences are \emph{not} logically equivalent.

Notice, though, that we cannot show that two sentences \emph{are} logically equivalent by simply producing a model. If we claim that two sentences are logically equivalent, we are once again making a claim about every possible model. 

\subsection{Models to show consistency}

Suppose I wanted to show that the set of sentences $\{\exists x Fx, \exists x \enot Fx, \forall x Gx\}$ is consistent. For this to be the case, we need at least one model where all three sentences are true. In this case that means having one object in our UD that is $F$ and one that is not $F$, and we need both of them to be $G$. This would do the trick.

\begin{partialmodel}
	UD				 & \{$\alpha$, $\beta$\}\\
	\extension{F}		& \{$\alpha$\} \\
	\extension{G}		& \{$\alpha$, $\beta$\} 
\end{partialmodel}

We cannot show a set of sentences to be inconsistent this way, because as before, that would mean creating an infinite number of models. 

\subsection{Models to show invalidity}

Back on p.~\pageref{surgeon3correct}, we said that this argument would be invalid in QL:
\begin{earg}
\item[] $(Rc \eand K_1c) \eand Tc$
\item[\therefore] $Tc \eand K_2c$
\end{earg}
In order to show that it is invalid, we need to show that there is some model in which the premises are true and the conclusion is false. We can construct such a model deliberately. Here is one way to do it:
\begin{partialmodel}
	UD			& \{$\alpha$\}\\
	\extension{T}	& \{$\alpha$\}\\
	\extension{K_1}	& \{$\alpha$\}\\
	\extension{K_2}	& $\emptyset$\\
	\extension{R}	& \{$\alpha$\}\\
	\referent{c}	& $\alpha$
\end{partialmodel}

As you have probably guessed, we cannot show an argument valid with models so simply.



%\begin{table}[t]
%\caption{It is relatively easy to answer a question if you can do it by constructing a model or two. It is much harder if you need to reason about all possible models. This table shows when constructing models is enough.}
%\label{table.ModelOrArgument}
%\begin{center}
%\begin{tabular*}{\textwidth}[t]{p{10em}p{10em}p{10em}}
%& {\centerline{YES}} & {\centerline{NO}}\\
%\cline{3-3}
%
%Is \script{A} a tautology? & {show that \script{A} must be true in any model} & \tablefbox{\emph{construct a model} in which \script{A} is false}\\
%\cline{3-3}
%
%Is \script{A} a contradiction? &  {show that \script{A} must be false in any model} & \tablefbox{\emph{construct a model} in which \script{A} is true}\\
%\cline{2-3}
%
%Is \script{A} contingent? & \tablefbox{\emph{construct two models}, one in which \script{A} is true and another in which \script{A} is false}\vline & {either show that \script{A} is a tautology or show that \script{A} is a contradiction}\\
%\cline{2-3}
%
%Are \script{A} and \script{B} equivalent? & {show that \script{A} and \script{B} must have the same truth value in any model} & \tablefbox{\emph{construct a model} in which \script{A} and \script{B} have different truth values}\\
%\cline{2-3}
%
%Is the set \model{A} consistent? & \tablefbox{\emph{construct a model} in which all the sentences in \model{A} are true} & {show that the sentences could not all be true in any model}\\
%\cline{2-3}
%
%Is the argument \mbox{`\script{P}, \therefore\ \script{C}'} valid? & {show that any model in which \script{P} is true must be a model in which \script{C} is true} & \tablefbox{\emph{construct a model} in which \script{P} is true and \script{C} is false}\\
%\cline{3-3}
%\end{tabular*}
%\end{center}
%\end{table}
%
%
%
%
%
%
%
%\subsection{Satisfaction}
%
%The formula $Px$ says, roughly, that $x$ is one of the $P$s. This cannot be quite right, however, because $x$ is a variable and not a constant. It does not name any particular member of the UD. Instead, its meaning in a sentence is determined by the quantifier that binds it. The variable $x$ must stand-in for every member of the UD in the sentence $\forall xPx$, but it only needs to stand-in for one member in $\exists xPx$. Since we want the definition of satisfaction to cover $Px$ without any quantifier whatsoever, we will start by saying how to interpret a free variable like the $x$ in $Px$.
%
%We do this by introducing a \emph{variable assignment}. Formally, this is a function that matches up each variable with a member of the UD. Call this function `a.' (The `a' is for `assignment', but this is not the same as the truth value assignment that we used in defining truth for SL.)
%
%The formula $Px$ is satisfied in a model \model{M} by a variable assignment $a$ if and only if $a(x)$, the object that $a$ assigns to $x$, is in the the extension of P in \model{M}.
%
%When is $\forall x Px$ satisfied? It is not enough if $Px$ is satisfied in \model{M} by $a$, because that just means that $a(x)$ is in \extension{P}. $\forall x Px$ requires that every other member of the UD be in \extension{P} as well.
%
%So we need another bit of technical notation: For any member $\Omega$ of the UD and any variable \script{x}, let $a[\Omega|\script{x}]$ be the variable assignment that assigns $\Omega$ to \script{x} but agrees with $a$ in all other respects. We have used $\Omega$, the Greek letter Omega, to underscore the fact that it is some member of the UD and not some symbol of QL. Suppose, for example, that the UD is presidents of the United States. The function $a[\mbox{Grover Cleveland}|x]$ assigns Grover Cleveland to the variable $x$, regardless of what $a$ assigns to $x$; for any other variable, $a[\mbox{Grover Cleveland}|x]$ agrees with $a$.
%
%We can now say concisely that $\forall x Px$ is satisfied in a model \model{M} by a variable assignment $a$ if and only if, for every object $\Omega$ in the UD of \model{M}, $Px$ is satisfied in \model{M} by $a[\Omega|x]$.
%
%You may worry that this is circular, because it gives the satisfaction conditions for the sentence $\forall x Px$ using the phrase `for every object.' However, it is important to remember the difference between a logical symbol like `$\forall$' and an English language word like `every.' The word is part of the metalanguage that we use in defining satisfaction conditions for object language sentences that contain the symbol.
%
%We can now give a general definition of satisfaction, extending from the cases we have already discussed. We define a function $s$ (for `satisfaction') in a model \model{M} such that for any wff \script{A} and variable assignment $a$, $s(\script{A}, a)=1$ if \script{A} is satisfied in \model{M} by $a$; otherwise $s(\script{A}, a)=0$.
%
%\begin{enumerate}
%\item If \script{A} is an atomic wff of the form $\script{P}\script{t}_1\ldots\script{t}_n$ and $\Omega_i$ is the object picked out by $t_i$, then
%\begin{displaymath}s(\script{A}, a) =
%	\left\{\begin{array}{ll}
%	1 & \mbox{if ${<}\Omega_1\ldots\Omega_n{>}$ is in \extension{\script{P}} in \model{M}},\\
%	0 & \mbox{otherwise.}
%	\end{array}\right.
%\end{displaymath}
%
%For each term $t_i$: If $t_i$ is a constant, then $\Omega_i = \referent{t_i}$. If $t_i$ is a variable, then $\Omega_i = a(t_i)$.
%
%\item If \script{A} is ${\enot}\script{B}$ for some wff \script{B}, then
%\begin{displaymath}s(\script{A}, a) =
%	\left\{\begin{array}{ll}
%	1 & \mbox{if $s(\script{B}, a) = 0$},\\
%	0 & \mbox{otherwise.}
%	\end{array}\right.
%\end{displaymath}
%
%\item If \script{A} is $(\script{B}\eand\script{C})$ for some wffs \script{B,C}, then
%\begin{displaymath}s(\script{A}, a) =
%	\left\{\begin{array}{ll}
%	1 & \mbox{if $s(\script{B}, a) = 1$ and $s(\script{C}, a) = 1$,}\\
%	0 & \mbox{otherwise.}
%	\end{array}\right.
%\end{displaymath}
%
%\item If \script{A} is $(\script{B}\eor\script{C})$ for some wffs \script{B,C}, then
%\begin{displaymath}s(\script{A}, a) =
%	\left\{\begin{array}{ll}
%	0 & \mbox{if $s(\script{B}, a) = 0$  and $s(\script{C}, a) = 0$,}\\
%	1 & \mbox{otherwise.}
%	\end{array}\right.
%\end{displaymath}
%
%\item If \script{A} is $(\script{B}\eif\script{C})$ for some wffs \script{B,C}, then
%\begin{displaymath}s(\script{A}, a) =
%	\left\{\begin{array}{ll}
%	0 & \mbox{if $s(\script{B}, a) = 1$ and $s(\script{C}, a) = 0$,}\\
%	1 & \mbox{otherwise.}
%	\end{array}\right.
%\end{displaymath}
%
%\item If \script{A} is $(\script{B}\eiff\script{C})$ for some sentences \script{B,C}, then
%\begin{displaymath}s(\script{A}, a) =
%	\left\{\begin{array}{ll}
%	1 & \mbox{if $s(\script{B}, a) = s(\script{C}, a)$},\\
%	0 & \mbox{otherwise.}
%	\end{array}\right.
%\end{displaymath}
%
%\item If \script{A} is $\forall\script{x} \script{B}$ for some wff \script{B} and some variable \script{x}, then
%\begin{displaymath}s(\script{A}, a) =
%	\left\{\begin{array}{ll}
%	1 & \mbox{if $s(\script{B}, a[\Omega|\script{x}])=1$ for every member $\Omega$ of the UD},\\
%	0 & \mbox{otherwise.}
%	\end{array}\right.
%\end{displaymath}
%
%\item If \script{A} is $\exists\script{x} \script{B}$ for some wff \script{B} and some variable \script{x}, then
%\begin{displaymath}s(\script{A}, a) =
%	\left\{\begin{array}{ll}
%	1 & \mbox{if $s(\script{B}, a[\Omega|\script{x}])=1$ for at least one member $\Omega$ of the UD},\\
%	0 & \mbox{otherwise.}
%	\end{array}\right.
%\end{displaymath}
%\end{enumerate}
% 
%This definition follows the same structure as the definition of a wff for QL, so we know that every wff of QL will be covered by this definition. For a model \model{M} and a variable assignment $a$, any wff will either be satisfied or not. No wffs are left out or assigned conflicting values.




%\section*{Summary of definitions}
%\begin{itemize}
%\item A \define{tautology in QL} is a sentence \script{A} that is true in every model; i.e.,  $\models\script{A}$.

%\item A \define{contradiction in QL} is a sentence \script{A} that is false in every model; i.e., $\models\enot\script{A}$.

%\item A sentence is \define{contingent in QL} if and only if it is neither a tautology nor a contradiction.

%\item An argument `` $\script{P}_1, \script{P}_2, \cdots$, \therefore\ \script{C} '' is \define{valid in QL} if and only if there is no model in which all of the premises are true and the conclusion is false; i.e., $\{\script{P}_1,\script{P}_2,\cdots\}\models\script{C}$. It is \define{invalid in QL} otherwise.

%\item Two sentences \script{A} and \script{B} are \define{logically equivalent in SL} if and only if both $\script{A}\models\script{B}$ and $\script{B}\models\script{A}$.

%\item The set $\{\script{A}_1,\script{A}_2,\script{A}_3,\cdots\}$ is \define{consistent in QL} if and only if there is at least one model in which all of the sentences are true. The set is \define{inconsistent in QL} if and if only there is no such model.
%\end{itemize}
\practiceproblems


\problempart
\label{pr.Contingent}
Show that each of the following is contingent.
\begin{earg}
\item \leftsolutions\ $Da \eand Db$
\item \leftsolutions\ $\exists x Txh$
\item \leftsolutions\ $Pm \eand \enot\forall x Px$
\item $\forall z Jz \eiff \exists y Jy$
\item $\forall x (Wxmn \eor \exists yLxy)$
\item $\exists x (Gx \eif \forall y My)$
\end{earg}


\problempart
\label{pr.NotEquiv}
Show that the following pairs of sentences are not logically equivalent.
\begin{earg}
\item $Ja$, $Ka$
\item $\exists x Jx$, $Jm$
\item $\forall x Rxx$, $\exists x Rxx$
\item $\exists x Px \eif Qc$, $\exists x (Px \eif Qc)$
\item $\forall x(Px \eif \enot Qx)$, $\exists x(Px \eand \enot Qx)$
\item $\exists x(Px \eand Qx)$, $\exists x(Px \eif Qx)$
\item $\forall x(Px\eif Qx)$, $\forall x(Px \eand Qx)$
\item $\forall x\exists y Rxy$, $\exists x\forall y Rxy$
\item $\forall x\exists y Rxy$, $\forall x\exists y Ryx$
\end{earg}



\problempart
Show that the following sets of sentences are consistent.
\begin{earg}
\item \{Ma, \enot Na, Pa, \enot Qa\}
\item \{$Lee$, $Lef$, $\enot Lfe$, $\enot Lff$\}
\item \{$\enot (Ma \eand \exists x Ax)$, $Ma \eor Fa$, $\forall x(Fx \eif Ax)$\}
\item \{$Ma \eor Mb$, $Ma \eif \forall x \enot Mx$\}
\item \{$\forall y Gy$, $\forall x (Gx \eif Hx)$, $\exists y \enot Iy$\}
\item \{$\exists x(Bx \eor Ax)$, $\forall x \enot Cx$, $\forall x\bigl[(Ax \eand Bx) \eif Cx\bigr]$\}
\item \{$\exists x Xx$, $\exists x Yx$, $\forall x(Xx \eiff \enot Yx)$\}
\item \{$\forall x(Px \eor Qx)$, $\exists x\enot(Qx \eand Px)$\}
\item \{$\exists z(Nz \eand Ozz)$, $\forall x\forall y(Oxy \eif Oyx)$\}
\item \{$\enot \exists x \forall y Rxy$, $\forall x \exists y Rxy$\}
\end{earg}


\problempart
Construct models to show that the following arguments are invalid.
\begin{enumerate}[label=\arabic*), topsep=0pt, parsep=0pt, itemsep=3pt]
\item $\forall x(Ax \eif Bx) \sdtstile{}{} \exists x Bx$
\item $\{\forall x(Rx \eif Dx)$, $\forall x(Rx \eif Fx)\} \sdtstile{}{} \exists x(Dx \eand Fx)$
\item $\exists x(Px\eif Qx) \sdtstile{}{} \exists x Px$
\item $Na \eand Nb \eand Nc \sdtstile{}{}  \forall x Nx$
\item $\{Rde$, $\exists x Rxd\} \sdtstile{}{} Red$
\item $\{\exists x(Ex \eand Fx)$, $\exists x Fx \eif \exists x Gx\} \sdtstile{}{} \exists x(Ex \eand Gx)$
\item $\{\forall x Oxc$, $\forall x Ocx\} \sdtstile{}{} \forall x Oxx$
\item $\{\exists x(Jx \eand Kx)$, $\exists x \enot Kx$, $\exists x \enot Jx\} \sdtstile{}{} \exists x(\enot Jx \eand \enot Kx)$
\item $\{Lab \eif \forall x Lxb$, $\exists x Lxb\} \sdtstile{}{} Lbb$
\end{enumerate}




\problempart
%problem using identity, with solutions
\label{pr.IdentityModels}
\begin{earg}
\item\leftsolutions\ Show that $\{{\enot}Raa, \forall x (x=a \eor Rxa)\}$
is consistent.
%There are many possible answers. Here is one:
%\begin{partialmodel}
%UD & \{Harry, Sally\}\\
%\extension{R} &\{$<$Sally, Harry$>$\}\\
%\referent{a} & Harry
%\end{partialmodel}
\item\leftsolutions\ Show that $\{\forall x\forall y\forall z(x=y \eor y=z \eor x=z),
\exists x\exists y\ x\neq y\}$ is consistent.
%There are no predicates or constants, so we only need to give a UD.
%Any UD with 2 members will do.
\item\leftsolutions\ Show that $\{\forall x\forall y\ x=y, \exists x\ x \neq a\}$ is inconsistent.
%We need to show that it is impossible to construct a model in which these are both true. Suppose $\exists x\ x \neq a\$ is true in a model. There is something in the universe of discourse that is \emph{not} the referent of $a$. So there are at least two things in the universe of discourse: \referent{a} and this other thing. Call this other thing \script{b}---we know $a \neq \script{b}$. But if $a \neq \script{b}$, then $\forall x\forall y\ x=y$ is false. So the first sentence must be false if the second sentence is true is true. As such, there is no model in which they are both true. Therefore, they are inconsistent.
\item Show that $\exists x (x = h \eand x = i)$ is contingent.
\item Show that \{$\exists x\exists y(Zx \eand Zy \eand x=y)$, $\enot Zd$, $d=s$\} is consistent.
\item Show that $\forall x(Dx \eif \exists y Tyx)$ \therefore\ $\exists y \exists z\ y\neq z$ is invalid.
\end{earg}




%\problempart
%\label{pr.SemanticsEssay}
%\begin{earg}
%\item Many logic books define consistency and inconsistency in this way:
%`` A set $\{\script{A}_1,\script{A}_2,\script{A}_3,\cdots\}$ is inconsistent if and only if $\{\script{A}_1,\script{A}_2,\script{A}_3,\cdots\}\models(\script{B}\eand\enot\script{B})$ for some sentence \script{B}. A set is consistent if it is not inconsistent.''
%
%Does this definition lead to any different sets being consistent than the definition on  p.~\pageref{def.consistencySL}? Explain your answer.
%
%\item\leftsolutions\ Our definition of truth says that a sentence \script{A} is \define{true in} \model{M} if and only if some variable assignment satisfies \script{A} in $M$. Would it make any difference if we said instead that \script{A} is \define{true in} \model{M} if and only if \emph{every} variable assignment satisfies \script{A} in $M$? Explain your answer.
%\end{earg}
